Command
./runscan ./disk_images/image-01 output

Reading first super-block from device: 
Block size                    : 1024
number of inodes in a block   : 8
Inode table size in blocks    : 160
Blocks per group              : 8192
number of block groups        : 2

Reading super-block from device: 
Inodes count            : 2560
Blocks count            : 10240
First data block        : 1
Block size              : 1024
log2(Block size)        : 0
Blocks per group        : 8192
Inodes per group        : 1280
First non-reserved inode: 11
Size of inode structure : 128

Reading group-descriptor from device:
Blocks bitmap block: 42
Inodes bitmap block: 43
Inodes table block : 44
Free blocks count  : 4446
Free inodes count  : 1267
Directories count  : 2


#include <stdio.h>
#include "ext2_fs.h"
#include "read_ext2.h"

int main(int argc, char **argv) {
	if (argc != 3) {
		printf("expected usage: ./runscan inputfile outputfile\n");
		exit(0);
	}
	
	int fd;

	fd = open(argv[1], O_RDONLY);    /* open disk image */

	ext2_read_init(fd); // parses ext2 disk image
  // An ext2 disk image file is a file system that we can mount.
 
  // takes 2 args: input file containing disk image, and output directory
  // to reconstruct all jpg files, scan all inodes
  // that represent reg files and check if first
  // data block of inode contains jpg magic numbers

  // this code identfies whether it is jpg or not given data block 
  // of file
  //int is_jpg = 0;
  //if (buffer[0] == (char)0xff &&
  //  buffer[1] == (char)0xd8 &&
  //  buffer[2] == (char)0xff &&
  //  (buffer[3] == (char)0xe0 ||
  //   buffer[3] == (char)0xe1 ||
  //   buffer[3] == (char)0xe8)) {
  //    is_jpg = 1;
  //}

  // then copy content of file to output file, using inode
  // number as file name. ex): output/file-18.jpg

  // next find out filenames of inodes representing jpg files
  // filenames are stored in diredctory data blocks
  // so, once you get inode numbers of jpg files,
  // scall all directory data blocks to find corresponding filenames

  // once found, copy content of that file to output file using 
  // its actual name

  // final output directory will have inode number file and filename
  // file

  char buffer[1024];
	struct ext2_super_block super;
	struct ext2_group_desc group;
	
	// example read first the super-block and group-descriptor
	read_super_block(fd, 0, &super);
	read_group_desc(fd, 0, &group);
	
	printf("There are %u inodes in an inode table block and %u blocks in the idnode table\n", inodes_per_block, itable_blocks);
	//iterate the first inode block
	off_t start_inode_table = locate_inode_table(0, &group);
  int inode_counter = 0; // may need to start at 1
  for (unsigned int j = 0; j < itable_blocks; j++) {
    for (unsigned int i = 0; i < inodes_per_block; i++) {
            printf("inode %u: block:%u\n", i, j);
            struct ext2_inode *inode = malloc(sizeof(struct ext2_inode));
            read_inode(fd, j, start_inode_table, i, inode);
	    /* the maximum index of the i_block array should be computed from i_blocks / ((1024<<s_log_block_size)/512)
			 * or once simplified, i_blocks/(2<<s_log_block_size)
			 * https://www.nongnu.org/ext2-doc/ext2.html#i-blocks
			 */
			unsigned int i_blocks = inode->i_blocks/(2<<super.s_log_block_size);
          printf("number of blocks %u, inode->i_blocks %u\n", i_blocks, inode->i_blocks);
             printf("Is directory? %s \n Is Regular file? %s\n",
                S_ISDIR(inode->i_mode) ? "true" : "false",
                S_ISREG(inode->i_mode) ? "true" : "false");
			
			// print i_block numberss
			for(unsigned int i=0; i<EXT2_N_BLOCKS; i++)
			{       if (i < EXT2_NDIR_BLOCKS)                                 /* direct blocks */
							printf("Block %2u : %u\n", i, inode->i_block[i]);
					else if (i == EXT2_IND_BLOCK)                             /* single indirect block */
							printf("Single   : %u\n", inode->i_block[i]);
					else if (i == EXT2_DIND_BLOCK)                            /* double indirect block */
							printf("Double   : %u\n", inode->i_block[i]);
					else if (i == EXT2_TIND_BLOCK)                            /* triple indirect block */
							printf("Triple   : %u\n", inode->i_block[i]);

			}
      
      //int file_size = inode->i_size; and subtract 1024 from total until fully copied
      if (S_ISDIR(inode->i_mode)) {
        // this inode represents a directory
        // idk procedure for reading a directory yet/probably has to do
        // with extracting file name
      } 
      else if (S_ISREG(inode->i_mode)) {  // checks if it is a regular block
        for(unsigned int i=0; i<EXT2_N_BLOCKS; i++) {
          if (i < EXT2_NDIR_BLOCKS) {                                  /* direct blocks */
            printf("Block %2u : %u\n", i, inode->i_block[i]);
            lseek(fd, BLOCK_OFFSET(inode->i_block[i]), SEEK_SET);
            read(fd, buffer, inode->i_size); //dunno if i_size is correct here, 1024 maybe
            
            int is_jpg = 0;
            if (buffer[0] == (char)0xff &&
              buffer[1] == (char)0xd8 &&
              buffer[2] == (char)0xff &&
              (buffer[3] == (char)0xe0 ||
              buffer[3] == (char)0xe1 ||
              buffer[3] == (char)0xe8)) {
              is_jpg = 1;
            }
            
            if (is_jpg) {
              //write();
            }
					} else if (i == EXT2_IND_BLOCK) {                            /* single indirect block */
					  printf("Single   : %u\n", inode->i_block[i]);
            
					} else if (i == EXT2_DIND_BLOCK) {                           /* double indirect block */
						printf("Double   : %u\n", inode->i_block[i]);
					} else if (i == EXT2_TIND_BLOCK) {                           /* triple indirect block */
						printf("Triple   : %u\n", inode->i_block[i]);
          }
			  }
      }
      else {
        // this inode represents other file types, pass
      }
			
      free(inode);
      inode_counter++;  // increment inode tracker
    }
  }

	printf("There are %u inodes\n", inode_counter);
	close(fd);
}

// locate regular file
// follow indirect pointers if need be
// lseek (use header file macro to calc offset) and read
// write to output file